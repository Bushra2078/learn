In this module, you're going to discover *traits* and *generics*, which are Rust's way to deal
with the concept of *polymorphism*. Together, they allow us to write code that acts on values of many
different types, even types that haven't been declared yet.

## Learning objectives

In this module, you'll learn:

- What generic types are and how "wrapper" types use them.
- What traits are and how they help us define shared behavior.
- How to implement an existing trait for a custom type.
- How to implement a custom trait for an existing type.
- How trait bounds help us write generic functions.

## Prerequisites

Have a solid understanding of Rust's types, ownerships, and moves. If you have any questions about those subjects, review the module *Understand ownership, borrowing, and lifetimes*.
