<!-- Original file: C:\Users\Mark\Desktop\CMU-source\v_5_3\content\_u05_distributed_programming_analytics_engines\_u05_m01_intro\x-oli-workbook_page\_u05_m01_1_intro.xml -->

Developing cloud programs (i.e., designing and implementing software systems that successfully exploit the capabilities of massively distributed computational resources) presents formidable challenges. The difficulties arise from the multiplicity of possible logical interactions and temporal interleavings among numerous software and hardware components. Program bugs can be difficult to reproduce, and due to some cloud programs' nondeterministic performance behavior, analyzing and reasoning a system's behavior<!-- about a system --> can exceed mere human ability.

As researchers and practitioners have gradually <!-- better understood this problem better -->gained a better understanding of this problem, they have developed<!-- evolved --> models of programming and computation that mitigate cloud systems' inherent complexity. These models, which are <!-- themselves -->embodied in software/hardware systems, stand between developer and underlying computational resources, providing the programmer stylized design patterns, a relatively simpler way of thinking about distributed programming, and a flexible interface to applications, data, and resources. 

The current generation of cloud programming models builds on classical predecessors that support interprocess communication based on shared memory and message passing. Although those earlier versions provide basic facilities for interaction among distributed tasks, they lack the capability to parallelize and distribute tasks automatically and to recover from faults. Those versions' modern descendants, including Hadoop MapReduce<!-- [2] [3] -->, Pregel<!-- [4] -->, and GraphLab<!-- [5] -->, provide greater sophistication and specifically address the demands of distributed programming and computing in cloud environments. Among other advantages, these current models relieve developers from concerns with many of the difficult aspects of distributed programming and allow programmers to focus on sequential portions of their application's algorithms. 

<!-- To distinguish these modern systems, and -->Echoing Babbage's 1837 design for the first programmable computer, we distinguish <!-- refer to -->today's cloud-programming models by referring to them as **distributed analytics engines**. This unit examines the concepts and challenges of cloud computing and provides current examples of analytics engines for developing cloud applications. 