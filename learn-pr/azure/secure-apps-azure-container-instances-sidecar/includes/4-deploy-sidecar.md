
As you might have noticed in the previous unit, the traffic to the application API runs unencrypted. Your customers do not appreciate this, and they demand that you use HTTPS instead of HTTP. You could enhance the application code so that it supports HTTPS, but you do not have access to the original team that developed the application. An alternative is to use a sidecar container that enhances the application with the required functionality. In this unit, you will use NGINX, a web server that can be used as a reverse-proxy in front of a web application, to provide SSL offload functionality. Encrypted traffic will enter the Azure Container Instances container group in the NGINX container, and NGINX will hand over the decrypted traffic to the actual application container.

![Diagram that shows topology of Azure Container Instances with NGINX sidecar.](../media/3-nginx-sidecar.png)

The Sidecar pattern is a powerful concept in container-based architectures. It allows you to decompose application functionality in different container images that will run together in the same container group.

Containers in the same container group will share some properties, such as the underlying network stack. Azure Container Instances actually represent a container group, in which each container can take over part of the functionality required by the application. In this example, you will deploy one container group where one of the containers will perform SSL encryption and decryption, and the other one will provide the actual application functionality (the same API deployed in previous units).

> [!NOTE]
> The concept of "container group" is equivalent to "pods" in Kubernetes.

## Create NGINX configuration

1. The first thing you will need is a digital certificate for data encryption. In this unit you will use a self-signed certificate, but in production you would use a digital certificate generated by a Certificate Authority:

    ```azurecli
    # Create self-signed certs
    openssl req -new -newkey rsa:2048 -nodes -keyout ssl.key -out ssl.csr -subj "/C=US/ST=WA/L=Redmond/O=AppDev/OU=IT/CN=contoso.com"
    openssl x509 -req -days 365 -in ssl.csr -signkey ssl.key -out ssl.crt
    ```

1. You will create a file containing the configuration for NGINX. You do not need to understand every detail, but some aspects of it are important:

    - The `proxy_pass` property points to `http://127.0.0.1:8080`. This is where the application container will be. The containers inside the container group (the NGINX and the application container) share the same network namespace. In other words, they can communicate with each other using the `localhost` or `127.0.0.1` address
    - The certificate file and key will be read from the `/etc/nginx/` directory, so you will have to insert the files generated above in the corresponding directory later in this unit
    - The sidecar container will listen to the TCP port 443

    ```azurecli
    # Create nginx.conf for SSL
    nginx_config_file=/tmp/nginx.conf
    cat <<EOF > $nginx_config_file
    user nginx;
    worker_processes auto;
    events {
      worker_connections 1024;
    }
    pid        /var/run/nginx.pid;
    http {
        server {
            listen [::]:443 ssl;
            listen 443 ssl;
            server_name localhost;
            ssl_protocols              TLSv1.2;
            ssl_ciphers                ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:ECDHE-RSA-RC4-SHA:ECDHE-ECDSA-RC4-SHA:AES128:AES256:RC4-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!3DES:!MD5:!PSK;
            ssl_prefer_server_ciphers  on;
            ssl_session_cache    shared:SSL:10m; # a 1mb cache can hold about 4000 sessions, so we can hold 40000 sessions
            ssl_session_timeout  24h;
            keepalive_timeout 75; # up from 75 secs default
            add_header Strict-Transport-Security 'max-age=31536000; includeSubDomains';
            ssl_certificate      /etc/nginx/ssl.crt;
            ssl_certificate_key  /etc/nginx/ssl.key;
            location / {
                proxy_pass http://127.0.0.1:8080 ;
                proxy_set_header Connection "";
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$remote_addr;
                proxy_buffer_size          128k;
                proxy_buffers              4 256k;
                proxy_busy_buffers_size    256k;
            }
        }
    }
    EOF
    ```

1. Now you will collect the files that you want to pass on to the NGINX sidecar container in base64-encoded variables:

    ```azurecli
    # Encode to Base64
    nginx_conf=$(cat $nginx_config_file | base64)
    ssl_crt=$(cat ssl.crt | base64)
    ssl_key=$(cat ssl.key | base64)
    ```

## Deploy container group with NGINX sidecar

1. You will use YAML to deploy Azure Container Instances. In the previous unit, you used the Azure Command Line Interface, but more complex configurations such as sidecars require using YAML. Another benefit of YAML-based configurations is that you can store them in version-control systems and treat them the same as your application code. If you look at the YAML generated in the previous unit, you can see that a "Network Profile" is referenced. You can either copy the profile ID from the YAML generated in the previous unit, or look it up using the `az network profile list` command:

    ```azurecli
    # Get network profile ID (it was created the first time you deployed an Azure Container Instance to the Virtual Network)
    nw_profile_id=$(az network profile list -g $rg --query '[0].id' -o tsv) && echo $nw_profile_id
    ```

1. Now you have all the required information to create the YAML file. You can combine all the information you have stored in variables in this unit in a single file. Here are a few things that you need to be aware of:

    - The SQL password is passed on as secured environment variable, so it is not exposed after creating Azure Container Instances
    - The NGINX container mounts the config volume in the `/etc/nginx/` directory, where the certificates are expected to be found as you saw earlier in this unit. The volume contents are specified as secrets, which is why you had to base64-encode the variables before.
    - The NGINX container exposes port 443, and the application container exposes port 8080. However, the container group only exposes port 443. This makes the application only reachable via the NGINX sidecar container.

    You will use YAML to specify these properties for the Azure Container Instance:

    ```azurecli
    # Create YAML
    aci_yaml_file=/tmp/aci_ssl.yaml
    cat <<EOF > $aci_yaml_file
    apiVersion: 2019-12-01
    location: westus
    name: $aci_name
    properties:
      networkProfile:
        id: $nw_profile_id
      containers:
      - name: nginx
        properties:
          image: nginx
          ports:
          - port: 443
            protocol: TCP
          resources:
            requests:
              cpu: 1.0
              memoryInGB: 1.5
          volumeMounts:
          - name: nginx-config
            mountPath: /etc/nginx
      - name: sqlapi
        properties:
          image: erjosito/sqlapi:1.0
          environmentVariables:
          - name: SQL_SERVER_USERNAME
            value: $sql_username
          - name: SQL_SERVER_PASSWORD
            secureValue: $sql_password
          - name: SQL_SERVER_FQDN
            value: $sql_server_fqdn
          ports:
          - port: 8080
            protocol: TCP
          resources:
            requests:
              cpu: 1.0
              memoryInGB: 1
      volumes:
      - secret:
          ssl.crt: "$ssl_crt"
          ssl.key: "$ssl_key"
          nginx.conf: "$nginx_conf"
        name: nginx-config
      ipAddress:
        ports:
        - port: 443
          protocol: TCP
        type: Private
      osType: Linux
    tags: null
    type: Microsoft.ContainerInstance/containerGroups
    EOF
    ```

1. After you put all the required configuration in the YAML file, the command to create Azure Container Instances is simple:

    ```azurecli
    # Deploy ACI
    az container create -g $rg --file $aci_yaml_file
    ```

1. You can now extract the IP address of the Azure Container Instances (it should be a private IP address) and access it via HTTPS from the test Virtual Machine. You should use the flag `-k` with curl so that it disables certificate validation, since you are using self-signed certificate in this unit. The `api/healthcheck` endpoint of the API should response with an `OK`:

    ```azurecli
    # Test
    aci_ip=$(az container show -n $aci_name -g $rg --query 'ipAddress.ip' -o tsv) && echo $aci_ip
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $vm_pip "curl -ks https://$aci_ip/api/healthcheck"
    ```

    Do not delete these Azure Container Instances, because you'll still use them in the next unit.

## Summary

You included an NGINX sidecar container next to the application inside of an Azure Container Instance. The sidecar container enhanced the application container with SSL functionality without having to modify the application code.
