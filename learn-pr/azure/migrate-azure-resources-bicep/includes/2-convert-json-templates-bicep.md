You have started the process of migrating your Azure resources to Bicep, and you want to start with converting your JSON templates to Bicep templates using the native tooling. You want to learn more about how Bicep works, how to use the Bicep decompiler, and how to revise your decompiled templates following a recommended workflow.

## How does Bicep work?

Bicep is a Resource Manager template language that's used to declaratively deploy Azure resources. It is a domain-specific language, which means that it's designed for a specific scenario or "domain." Bicep isn't meant to be used as a programming language for applications. It is used only to create Resource Manager templates.

When you submit a Bicep template for deployment to Resource Manager, the tooling converts your Bicep template into a JSON template. This process is known as _transpilation_, which essentially treats the ARM template as an intermediate language. The conversion happens automatically when you submit your deployment, or you can do it manually.

:::image type="content" source="../../includes/media/bicep-to-json.png" alt-text="Diagram that shows a template author, a Bicep template, an emitted JSON template, and a deployment to Azure." border="false":::

> [!NOTE]
> Transpilation is the process of converting source code written in one language into another language.

## What is the Bicep decompiler?

Your first step in migrating your Azure resources to Bicep is to convert your ARM JSON templates to Bicep templates.

The Bicep tooling includes the `decompile` command, which is used to convert a JSON template to a Bicep template. You can invoke the `decompile` command from either the AZ CLI, or from the Bicep CLI.

The decompilation process is a best-effort process and does not guarantee a full mapping from JSON to Bicep. You may need to revise the generated Bicep file to meet your template best practices before using the file to deploy resources. Later in this unit, you will learn how to fix any issues encountered in the decompilation process.

### Decompile an ARM JSON template to Bicep

To decompile an ARM JSON template to Bicep with the Azure CLI, use:

```azurecli
az bicep decompile --file main.json
```

To decompile an ARM JSON template to Bicep with the Bicep tooling, use:

```bicep
bicep decompile --file main.json
```

Both commands will create a file named main.bicep in the same directory as the original JSON template.

> [!NOTE]
> The [Bicep playground](https://bicepdemo.z22.web.core.windows.net/) is an online tool that compares JSON templates and Bicep templates side by side. You can choose an Azure quickstart template or upload your own template by clicking the `Decompile` button.

## Recommended workflow for converting templates

In the previous section you learned that the decompilation is a best-effort process, and you may need to revise the generated Bicep file. When you convert your JSON templates to Bicep templates, follow this recommended workflow to help meet your template best practices.

1. **Create a new Bicep file** - Using [Visual Studio Code](https://code.visualstudio.com/), create a new Bicep file. This new file will become the main template file for your converted template.

2. **Decompile the source ARM JSON template** - From a terminal window, run either the `az bicep decompile` or the `bicep decompile` command against your source JSON template to convert the file to a Bicep template. Using Visual Studio Code, open your new Bicep file and the decompiled JSON file side by side.

3. **Copy the resources from converted Bicep file to new Bicep file** - For each defined resource in your original JSON template, copy it from the converted Bicep file to the new Bicep file. Consider copying the resources individually, so that you can resolve any issues on a per resource basis.

4. **Review the linter suggestions in your new Bicep file** - When creating Bicep files using the [Bicep extension for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-bicep), the linter runs automatically and highlights suggestions and errors in your code. Many of the suggestions and errors include an option to apply a quick fix of the issue. Review these recommendations and adjust your Bicep file.

5. **Revise parameters, variables, and symbolic names** - It is possible that the names of parameters, variables, and symbolic names generated by the decompiler will not match your standard naming convention. Review the generated names and make adjustments as necessary.

6. **Simplify expressions** - The decompile process may not always take advantage of some of Biceps features. Review any expressions generated in the conversion and simplify them. This may include a concat function that could be simplified using string interpolation. Review any suggestions from the linter and make adjustments as necessary.

7. **Review child and extension resources** - With Bicep, there are multiple ways to declare child and extension resources. Consider reviewing these resources after decompilation and make sure that the structure meets your standards. For example, Subnets can either be referenced as properties of a Virtual Network, or as a separate resource. Make any necessary changes to child and extension resources.

8. **Modularize** - If you are converting a template that has a number of resources, consider breaking the individual resource types into modules for simplicity. Bicep modules help to reduce the complexity of your template deployments.

   > [!NOTE]
   > It is possible to use your JSON templates as modules in a Bicep deployment. Bicep has the ability to recognize JSON modules and reference them the same way as Bicep modules.

9. **Add comments** - Good Bicep code is _self-documenting_! Bicep provides the ability to add comments to your code that help you document your infrastructure. This can help your teammates understand the code, and increase confidence when changes are made. These comments are ignored when the Bicep file is deployed to Azure.

10. **Perform a test deployment** - Before introducing your converted Bicep template to production, consider running multiple test deployments. If you have multiple environments (prod, dev, test), you may want to try deploying your template to one of your non-production environments first.

    > [!NOTE]
    > If you are going to use the converted template in a pipeline, such as Azure DevOps or GitHub Actions, consider running the deployment from your local machine first. It is better to verify the functionality of the template before adding it to your production pipeline.

## Make improvements to decompiled templates

After using the Bicep decompiler to convert your JSON template to a Bicep template, you will want to make some improvements to the file. These improvements may include changes that bring the template in line with your team's code standards as well as general best practices with Bicep templates.

Take a look at the following JSON template which creates an Azure App Service Plan.

```JSON
{
    "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
    "contentVersion": "1.0.0.0",
    "parameters": {
        "location": {
            "type": "string",
            "defaultValue": "[resourceGroup().location]",
            "metadata": {
                "description": "Location for resources."
            }
        },
        "environment": {
            "type": "string",
            "defaultValue": "prod",
            "allowedValues": [
                "prod",
                "dev",
                "test"
            ],
            "metadata": {
                "description": "The list of allowed environment names."
            }
        },
        "appServicePlanSku": {
            "type": "string",
            "defaultValue": "P1v3",
            "allowedValues": [
                "P1v3",
                "P2v3",
                "P3v3"
            ],
            "metadata": {
                "description": "The list of allowed App Service Plan SKUs."
            }
        },
        "appServicePlanInstanceCount": {
            "type": "int",
            "defaultValue": 1,
            "minValue": 1,
            "maxValue": 10,
            "metadata": {
                "description": "The number of allowed App Service Plan instances."
            }
        }
    },
    "variables": {
        "appServicePlanName": "[concat('plan-', parameters('environment'), '-001')]"
    },
    "resources": [
        {
            "type": "Microsoft.Web/serverfarms",
            "apiVersion": "2020-12-01",
            "name": "[variables('appServicePlanName')]",
            "location": "[parameters('location')]",
            "sku": {
                "name": "[parameters('appServicePlanSku')]",
                "capacity": "[parameters('appServicePlanInstanceCount')]"
            },
            "kind": "app",
            "properties": {}
        }
    ],
    "outputs": {
        "appServicePlanId": {
          "type": "string",
          "value": "[resourceId('Microsoft.Web/serverfarms', variables('appServicePlanName'))]"
        }
    }
}
```

When you run the Bicep `decompile` command against this template, the following Bicep template is generated:

```Bicep
@description('Location for resources.')
param location string = resourceGroup().location

@allowed([
  'prod'
  'dev'
  'test'
])
@description('The list of allowed environment names.')
param environment string = 'prod'

@allowed([
  'P1v3'
  'P2v3'
  'P3v3'
])
@description('The list of allowed App Service Plan SKUs.')
param appServicePlanSku string = 'P1v3'

@minValue(1)
@maxValue(10)
@description('The number of allowed App Service Plan instances.')
param appServicePlanInstanceCount int = 1

var appServicePlanName_var = 'plan-${environment}-001'

resource appServicePlanName 'Microsoft.Web/serverfarms@2020-12-01' = {
  name: appServicePlanName
  location: location
  sku: {
    name: appServicePlanSku
    capacity: appServicePlanInstanceCount
  }
  kind: 'app'
  properties: {}
}

output appServicePlanId string = appServicePlanName.id
```

If you were to deploy this Bicep template as is, the deployment would succeed, but there are a few things you could do to improve the template and bring it line with best practices.

### Revise parameters, variables, and symbolic names

One of the main tasks in converting our JSON templates to Bicep templates is to revise the names of parameters, variables, and symbolic names. The Bicep decompiler may add some additional text to these names that may not adhere to your template standards.

In the converted template, take a look at the variable `appServicePlanName_var`. This variable name has `_var` appended to the end of the original variable name.

:::code language="bicep" source="code/2-app-service-plan.bicep" range="20-27" highlight="6" :::

For clarity, remove the `_var` and shown below:

```Bicep
var appServicePlanName = 'plan-${environment}-001'
```

By making this change to the `appServicePlanName` variable, any reference to the original variable name will need to be updated. Look for any linting errors within the code that highlight where the variable needs to be updated. The value for `name:` needs to be updated with the new variable name.

:::code language="bicep" source="code/2-app-service-plan.bicep" range="27-29" highlight="2" :::

For clarity, remove the `_var` and shown below:

```Bicep
name: appServicePlanName
```

After updating the variable name and its references, notice that the `appServicePlanName` variable shares the same name as the `appServicePlanName` symbolic name.

:::code language="bicep" source="code/2-app-service-plan.bicep" range="27-29" highlight="1" :::

Modify the name of the symbolic name to `appServicePlan` as shown below:

```Bicep
resource appServicePlan 'Microsoft.Web/serverfarms@2020-12-01' = {
```

By making this change to the `appServicePlan` symbolic name, any reference to the original symbolic name will need to be updated. Look for any linting errors within the code that highlight where the symbolic name needs to be updated. The value for the `appServicePlanId` output needs to be updated based on the new symbolic name.

:::code language="bicep" source="code/2-app-service-plan.bicep" range="35-38" highlight="4" :::

Modify the value of the `appServicePlanId` output as shown below:

```Bicep
output appServicePlanId string = appServicePlan.id
```

### Add comments

Another good practice is to add comments to your Bicep templates. These self-documenting comments can help make your templates easy to understand, even for teammates that may not be familiar with the resources declared in the template.

Bicep supports both single line comments using a `//` character sequence and multi-line comments that start with a `/*` and end with a `*/`. Adding comments to specific lines in your code as well as for sections of code.

You can add a multi-line comment at the beginning of the file as shown below:

```Bicep
/*
  This Bicep file was developed by the web team.
  It deploys the resources we need for our toy company's website.
*/
```

Single line comments can be added as headers for sections of code, or on individual lines to describe the code.

:::code language="bicep" source="code/2-app-service-plan-updated.bicep" range="34-46" highlight="34,39,42,46" :::

### The converted template

```Bicep
/*
  This Bicep file was developed by the web team.
  It deploys the resources we need for our toy company's website.
*/

// parameters
@description('Location For All Resources.')
param location string = resourceGroup().location

@allowed([
  'prod' // Production environment
  'dev' // Development environment
  'test' // Test environment
])
@description('The list of allowed environment names.')
param environment string = 'prod'

@allowed([
  'P1v3' // 195 ACU/vCPU, 8GB memory, 2 vCPU
  'P2v3' // 195 ACU/vCPU, 16GB memory, 4 vCPU
  'P3v3' // 195 ACU/vCPU, 32GB memory, 8 vCPU
])
@description('The list of allowed App Service Plan SKUs.')
param appServicePlanSku string = 'P1v3'

@minValue(1)
@maxValue(10)
@description('The number of allowed App Service Plan instances.')
param appServicePlanInstanceCount int = 1

// variables
var appServicePlanName = 'plan-${environment}-001'

// resource - app service plan
resource appServicePlan 'Microsoft.Web/serverfarms@2020-12-01' = {
  name: appServicePlanName
  location: location
  sku: {
    name: appServicePlanSku // Specifies the SKU of the App Service Plan.
    capacity: appServicePlanInstanceCount
  }
  kind: 'app' // Specifies a Windows App service Plan.
  properties: {}
}

output appServicePlanId string = appServicePlan.id // Outputs the resource Id of the App Service Plan.

```
