Bicep gives you a lot of flexibility to decide how you structure your code. You can organize your template in the way you like and apply your own style.

In this unit, you'll learn about the way you style your Bicep code, and the importance of a consistent style and clear, understandable Bicep code. You'll also start to think about how to improve the Bicep file that you saw earlier.

## How are your resources named?

In Bicep, it's important that you give your resources meaningful names. Resources in Bicep have two names:

- The symbolic name is only used within the Bicep file and doesn't appear in Azure. This helps anyone who reads or modifies your template to understand the purpose of the resource and its configuration, so they can make an informed decision about whether to change it.
- The resource name is the name of the resource that's created in Azure. Many resources have constraints on their names, and may require unique names.

### Symbolic names

It's important to think about the symbolic names you apply to your resources. Imagine that a colleague will need to modify the template - will they understand what each resource does?

For example, imagine you're defining a storage account. The storage account will contain product manuals for users to download from your website. You could name give the resource a symbolic name of  `storageAccount`, but if it's in a Bicep file that contains lots of other resources - and maybe even other storage accounts - then that name isn't very descriptive. So you could instead give it a symbolic name that includes a bit of information about its purpose - like perhaps `productManualStorageAccount`.

### Capitalization

In Bicep, you typically use camel case for the names of parameters, variables, and resource symbolic names. If you choose to use a different style, it's important to agree on one standard within your team and use it consistently.

> [!NOTE]
> _Camel case_ means that you use a lowercase first letter for the first word, and then capitalize the first letter of subsequent words - like in `productManualStorageAccount`. Other capitalization styles include:
> - Pascal case (`ProductManualStorageAccount`)
> - Snake case (`product_manual_storage_account`)
> - Flat case (`productmanualstorageaccount`)
> - Train case (`Product-Manual-StorageAccount`)

### Change symbolic names in Visual Studio Code

When you rename identifiers, you need to make sure you rename them consistently in all parts of your template. This is especially important for parameters, variables, and resources that you refer to throughout your template.

Visual Studio Code offers a convenient way to rename symbols: select the identifier you want to rename, press <kbd>F2</kbd>, enter a new name, and press <kbd>Enter</kbd>:

:::image type="content" source="../media/4-rename-symbol.png" alt-text="Screenshot from Visual Studio Code showing how to rename a symbol." border="true":::

This renames the identifier, and all of the references to it as well.

### Resource names

TODO

> [!WARNING]
> I haven't updated this section yet.

Almost every resource type has certain naming [rules and restrictions](/azure/azure-resource-manager/management/resource-name-rules).

Many organizations define their own naming convention that works for them. There's a specific [guidance](/azure/cloud-adoption-framework/ready/azure-best-practices/naming-and-tagging) in the Cloud Adoption Framework for Azure that can help you define yours.

Following the naming convention can become a complex problem, especially since you can't rename your resource post deployment. A well-written Bicep template should hide this complexity from its users and determine the names for resources automatically.

There are two common patterns that can be used (or even combined):

- using **parameter decorators** to limit and validate inputs from users
- using variables to construct resource names internally and using parameters to receive only parts of resource names. Typically a prefix or a suffix

In our template, there are several variables used to generate resource names, for example the `hostingPlanName` variable used for the `serverfarms` resource name:

```bicep
var hostingPlanName = 'hostingplan${uniqueString(resourceGroup().id)}'
```

> [!IMPORTANT]
> You should always check what rules apply to resources you have in your templates and ensure incorrect names won't break the deployment.

In this specific example, the `serverfarms` resource [requires](/azure/azure-resource-manager/management/resource-name-rules) its name must be:

- unique within the resource group,
- the length can be between 1-40 alphanumeric characters (with an option to use hyphens).

The variable above is a concatenation of `hostingplan` string and an autogenerated, [unique](/azure/azure-resource-manager/templates/template-functions-string), 13 characters long string, that is derived from the Resource Group ID.

Since the only dynamic part is the unique string, we're certain that it will always match the rules. If we wanted to allow users to influence how the final name looks like, we could introduce a new parameter for name prefix. We would use the `@maxLenght()` decorator to ensure the prefix won't exceed 27 characters and add the `@description()` decorator to provide additional information.

```bicep
@maxLength(27)
@description('Naming prefix for web farm resource. Only alphanumeric characters and hyphen are allowed. Max size is 27 characters.')
param hostingPlanNamePrefix string = 'hostingplan'

var hostingPlanName = '${hostingPlanNamePrefix}${uniqueString(resourceGroup().id)}'
```

TODO END

## How understandable are the parameters?

Parameters help to make Bicep files reusable and flexible. However, it's important that the purpose of each parameter is clear. Most of the time, when yuo your colleagues work with your template they'll use parameters to change the behavior of their deployment, so it's critical that parameters are clearly named.

Default values are an important way to make your template usable by others. It's important to use default values where they make sense.

Bicep can also help to validate the input that the user provides when they deploy the template. Your Bicep files use _parameter decorators_ to help Bicep and the user understand what values are permitted for each parameter.

## How do you express dependencies between your resources?

In any complex Bicep template, you need to have _dependencies_ between your resources. When Bicep understands the dependencies between your resources, it deploys them in the correct order.

Bicep allows you to explicitly specify a dependency by using the `dependsOn` property. However, in most cases, it's possible to let Bicep automatically detect dependencies. When you use the symbolic name of one resource within a property of another, Bicep detects the relationship. It's better to let Bicep manage these itself whenever you can. That way, when you change your template, Bicep will make sure the dependencies are always correct, and you won't add unnecessary code that makes your template more cumbersome and harder to read.

## How do you express parent-child relationships?

Azure Resource Manager and Bicep have the concept of _child resources_, which only make sense to deploy within the context of their parent. For example, a SQL database is a child of a SQL server. There are several ways to define child resources, but in most cases, it's a good idea to use the `parent` property. This helps Bicep to understand the relationship, and it makes it clear to anyone else who reads the template too.

## How do you set resource properties?

You need to specify the values for resource properties in your Bicep files. It's a good idea to avoid hard-coding values directly, unless you know they won't change. This makes your Bicep template more dynamic and reusable. When you do hard-code values, it's good to make sure the values are understandable to others. For example, if you have to include a specific value for your resource to do what you need, consider creating a well-named variable and assigning the value using that. Or, consider adding a comment - you'll learn more about comments soon.

For some resource properties, you need to create complex expressions, and then use functions and string interpolation to construct values automatically. Your Bicep code is usually clearer when you declare variables and reference them in the resource code blocks.

## What order should your Bicep code follow?

TODO

> [!WARNING]
> I haven't updated this section yet.

Your Bicep templates can contain many **elements**:

- parameters (with or without default values)
- variables
- resources (including syntaxes for conditional and iterative deployments)
- modules (also with conditional and iterative deployments, or deployments to different scopes)
- outputs (with an option of iterative syntax)
- target scope for the entire template

As a declarative language that doesn't come with a strict schema, **these elements can be written in any order**. During the deployment, when your Bicep file is compiled to a Resource Manager template, all the elements will be placed according to the JSON schema.

There are **two authoring styles** used in the community. You and your team should agree on one and use it consistently:

### All element types grouped together

- our original template follows this style
- easy to adopt if you have a prior experience with Resource Manager templates
- for bigger templates it can be challenging to navigate and jump between the elements

  > [!TIP]
  > To overcome this challenge you can use built-in features in VS Code like "Go to Definition", "Find All References", or "Peak Definition".

### All elements belonging to one resource grouped together

- exceptions are common elements like the `location` parameter in our template. Those common elements should be placed together, ideally at the top of the Bicep file.
- it can simplify navigation

In our project, we'll use the first style. *Practically it means we won't need to make many structural changes.*

TODO END

## Choose free-form vs. known configurations

TODO

> [!WARNING]
> I haven't updated this section yet.

One of the goals is to design and author a reusable and flexible infrastructure code. You don't want to have single-purpose templates with hardcoded configuration. On the other hand, exposing all resource properties as parameters can be problematic too. There are two common approaches you can choose from:

### Free-form configuration

- provides maximum flexibility and many variations
- all resource properties are made available as parameters, allowing the user to provide all input values
- makes it difficult to exclude incorrect combinations and apply input validations

  > [!TIP]
  > Having potentially dozens of parameters in a template can be overwhelming. This could be simplified by grouping related parameters together in form of a parameter object. This will however reduce your ability to validate provided inputs.

### Known configuration

- also known as *T-shirt sizing*
- allows you to select from a set of defined configurations based on size, criticality, or environment type
- offers lower flexibility but delivers tested and validated configurations
- it also abstracts more complexity from end users, for example a domain-specific knowledge
- it's easier to support, test, and troubleshoot

If we wanted to use the second approach for our template, instead of exposing all the capacity details for the `serverFarm` resource, we could introduce two "sizes":

| Environment  | Specification  |
|---------|---------|
|Production     | P2V3 SKU and three worker nodes        |
|Test     | S2 SKU and one worker node        |

To implement this change, we would:

1. Create a new `environment` parameter with two allowed values,
2. Add a `webFarmSizing` variable that would hold both configuration options, and
3. Update the `sku` property in the `hostingPlan` resource.

The following code snippet shows how such implementation could look like:

```bicep
@description('Select what environment you want to provision. Allowed values are Production and Test')
@allowed([
  'Production'
  'Test'
])
param environment string = 'Test'

var webFarmSizing = {
  Production: {
    name: 'P2V3'
    capacity: 3
  }
  Test: {
    name: 'S2'
    capacity: 1
  }
}

...

resource hostingPlan 'Microsoft.Web/serverfarms@2020-06-01' = {
  name: hostingPlanName
  location: location
  sku: webFarmSizing[environment]
}
```

TODO END

## Use version control effectively

Version control systems like Git can help a lot when you're refactoring code.

Since version control systems are designed to keep track of the changes to your files, you can use them to easily return to an older version of your code if you make a mistake. It's a good idea to commit your work often so that you can go back to the exact point in time that you need.

Version control also helps you to avoid keeping old code in your Bicep files. Imagine that your Bicep code includes a resource definition that you don't need anymore. But, you might feel like there's a chance you could need the resource definition again in the future. It might be tempting to comment out the resource definition so you keep it in the file. This actually just clutters up your Bicep files, and makes it hard for anyone else to understand what's going on and the commented-out resources are there. It's also easy for someone to accidentally uncomment the definition in future, leading to unpredictable results. Instead, when you use a version control system, you can simply remove the old resource definition. If you need to see it again in the future, you can always go back to the history of the file.
