There is one last operation we need to look at before our new model is complete. Our last operation is to query our top 10 customers by the number of sales orders. In our current model, we first need to do a group by on each customer and sum for sales orders in our customer container, then sort in descending order and take the top 10 results. Even though customers and sales orders sit in the same container, this type of query is not something you can currently do.

The solution here is to denormalize and create a new property in the customer document, 'salesOrderCount'. This property will allow us to write a query like this one below to get this data.

:::image type="content" source="../media/7-sales-order-count.png" alt-text="Diagram with customer model that includes new sales order count property, customer container, and new query for getting our top 10 customers using the new sales order count property." border="false":::

Next, we now need a way where every time a customer creates a new sales order and a new sales order is inserted into our customer container, we update the customer document and increment the salesOrderCount property by one. To do this, we need a transaction. Azure Cosmos DB supports transactions when the data sits within the same logical partition. Since the customer and sales order all reside in the same logical partition, we can insert the new sales order and update the customer document within a transaction. There are two choices for implementing transactions in Azure Cosmos DB, stored procedures or using a feature called Transactional Batch available in both .NET or Java SDKs.

:::image type="content" source="../media/7-sales-order-customer-transaction.png" alt-text="Diagram with customer container and arrows showing that when a new sales order is created, the existing customer document is updated with the new sales order total." border="false":::
