This exercise takes you through the process of creating and configuring an Express.js-based web service that provides access to Azure Database for PostgreSQL. For more in-depth knowledge and tutorials about this topic, refer to:

* [Quickstart: Use Node.js to connect and query data in Azure Database for PostgreSQL - Single Server](/azure/postgresql/connect-nodejs?azure-portal=true)
* [Tutorial: Node.js for Beginners](/windows/dev-environment/javascript/nodejs-beginners-tutorial?azure-portal=true)

In this exercise, you'll:

* Create a sample Node.js Express web app.
* Connect the Node.js Express web app to Azure Database for PostgreSQL.
* Configure Node.js Express routes for access to Azure Database for PostgreSQL.
* Validate the functionality of the Node.js Express web service.

## Prerequisites

To perform this exercise, you need:

* An Azure subscription.
* A Microsoft account or an Azure AD account with the Global Administrator role in the Azure AD tenant that's associated with the Azure subscription and with the Owner or Contributor role in the Azure subscription.
* To have completed the first exercise of this module. You'll use the Azure PostgreSQL database you created and configured in that exercise.

## Create a sample Node.js Express web app

You'll begin by creating a sample Node.js Express web app and apply to it incremental changes to implement the desired functionality.

1. If needed, from your computer, start a web browser, navigate to the [Azure portal](https://portal.azure.com/?azure-portal=true) and sign in to access the Azure subscription you used in the first exercise of this module.
1. In the Azure portal, start a Bash session within the **Cloud Shell** by selecting its icon in the toolbar next to the search text box.
1. Within the Bash session on the **Cloud Shell** pane, run the following command to initialize a Node.js project in a new directory:

    ```azurecli-interactive
    mkdir -p cna-express && cd cna-express
    npm init -y
    ```

    > [!NOTE]
    > This creates a package.json, which contains all dependencies for the project.

1. Run the following command to add Express.js as the project's dependency:

    ```azurecli-interactive
    npm install express
    ```

1. Next, use the nano editor to create a ﬁle named **index.js** in the root of the project and add to it the following content:

    ```javascript
    const express = require('express')
    const port = process.env.PORT || 8080
    const app = express()
    app.use(express.json());
    app.listen(port, () => console.log(`Sample app is listening on port ${port}!`))
    ```

    > [!NOTE]
    > The script invokes the app, configuring it to listen on TCP port **8080** and to accept the JSON-formatted body of HTTP requests. Starting with Express 4.16+, `app.use(express.json())` is required for JSON parsing.

    > [!NOTE]
    > The use of **process.env.PORT** is specific to containers on Azure App Service, which sets the environment variable **PORT** in the Node.js container and sends the incoming requests to that port number. To receive the requests, your app should listen to that port using **process.env.PORT** (hence the use of `const port = process.env.PORT || 8080`).

    > [!NOTE]
    > You'll use Azure App Service in this exercise to facilitate testing of the Node.js Express functionality. It would be straightforward to containerize the app you develop and deploy it to any Kubernetes implementation, including AKS.

1. To allow the script to run, use the nano editor to modify the autogenerated **package.json** file so it has the following content:

    ```javascript
    {
      "name": "node-express",
      "version": "1.0.0",
      "description": "Node.js express sample",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "start": "nodemon index.js"
      },
      "author": "",
      "license": "ISC",
      "dependencies": {
        "body-parser": "^1.19.0",
        "express": "^4.17.1",
        "http": "0.0.0",
        "morgan": "^1.10.0"
      },
      "devDependencies": {
        "nodemon": "^2.0.2"
      }
    }
    ```

## Connect the Node.js Express web app to Azure Database for PostgreSQL

Next, you'll configure your newly created Node.js Express web app to connect to the **cnainventory** database you created in the previous exercise of this module. To do this, you'll use Sequelize, which is a popular JavaScript library that provides the Object-Relation Mapper functionality, allowing you to map programmatic constructs into corresponding database schema.

1. From your computer, in the web browser window displaying the Azure portal, within the Bash session in the **Cloud Shell** pane, run the following command to add Sequelize and the corresponding PostgreSQL-specific packages into your project:

    ```azurecli-interactive
    npm i sequelize pg pg-hstore
    ```

1. To take advantage of these new capabilities, use the nano editor to add the following line to the beginning of the **index.js** file:

    ```javascript
    const Sequelize = require('sequelize')
    ```

1. To establish a connection to the database, you need to add a connection string in the Sequalize-specific format to the **index.js** file following the line you added in the previous step. Replace the `<server_name>` placeholder with the name of the Azure Database for PostgreSQL server you provisioned in the previous exercise:

    ```javascript
    const sequelize = new Sequelize('postgres://Student%40<server_name>:Pa55w0rd1234@c<server_name>.postgres.database.azure.com:5432/cnainventory')
    ```

    > [!NOTE]
    > The use of **%40** as the escape character between the username and the server name is specific to connection strings for Azure Database for PostgreSQL.

1. With the Sequelize package included as a requirement and the connection string configured, you can now establish a connection to the **cnainventory** database by adding the following line to the **index.js** file after the one you added in the previous step:

    ```javascript
    sequelize
    .authenticate()
    .then(() => {
       console.log('Connection has been established successfully.');
    })
    .catch(err => {
       console.error('Unable to connect to the database:', err);
    });
    ```

1. To facilitate operations on the **inventory** table you created in the previous exercise, you need to add to the **index.js file** a Sequelize-specific definition matching the table format:

    ```javascript
    const Inventory = sequelize.define('inventory', {
       id: { type: Sequelize.INTEGER, allowNull: false, primaryKey: true },
       name: { type: Sequelize.STRING, allowNull: false },
       quantity: { type: Sequelize.INTEGER },
       date: { type: Sequelize.DATEONLY, defaultValue: Sequelize.NOW }
    }, {
       freezeTableName: true,
       timestamps: false
    });
    ```

    > [!NOTE]
    > The `timestamps: false` option is required to exclude from the scope of database operations a set of time-related columns, which, in this case, don't exist. The `freezeTableName: true` option disables the default behavior of Sequelize, which automatically transforms all model names into plural.

## Configure Node.js Express routes for access to Azure Database for PostgreSQL

Now you're ready to configure the routes that will provide read and write access to the **inventory** table in the **cnainventory** database hosted by the Azure Database for PostgreSQL server. For simplicity, you'll implement only two routes, but the procedure for configuring other routes would closely resemble the implementation you'll move through in this task. The first route will process HTTP GET requests, returning an inventory item based on the value of its **id** attribute, while the second route will allow you to add individual inventory items by invoking an HTTP POST request with the inventory item values included in the request body.

1. From your computer, in the web browser window displaying the Azure portal, within the Bash session on the **Cloud Shell** pane, use the nano editor to add the following content to the **index.js** file:

    ```javascript
    app.post('/inventory', async (req, res) => {
    try {
       const newItem = new Inventory(req.body)
       await newItem.save()
       res.json({ inventory: newItem })
    } catch(error) {
       console.error(error)
    }})
    ```

    > [!NOTE]
    > This part of the script manages the HTTP POST requests, adding a row to the **inventory** table that's populated with the values of **id**, **name**, and **quantity** attributes included in the request body. The value of the **date** attribute is calculated automatically based on the current date. The operation returns the newly added values as a confirmation of successful operation.

1. In the nano editor, add the following content to the **index.js** file following the script you added in the previous step:

    ```javascript
    app.get('/inventory/:id', async (req, res) => {
       const id = req.params.id
       try {
          const inventory = await Inventory.findAll({
          attributes: ['id', 'name', 'quantity', 'date'],
          where: {
             id: id
          }})
          res.json({ inventory })
       } catch(error) {
           console.error(error)
    }})
    ```

    > [!NOTE]
    > This part of the script manages the HTTP GET requests, returning the values of **id**, **name**, **quantity**, and **date** attributes based on the value of **id** included in the request.

    > [!NOTE]
    > This yields a fully functional script with the following content:
    >
    ```javascript
    const express = require('express')
    const Sequelize = require('sequelize')
    const sequelize = new Sequelize('postgres://Student%40cnapostgresqldb:Pa55w0rd1234@cnapostgresqldb.postgres.database.azure.com:5432/cnainventory')
    const port = process.env.PORT || 8080
    const app = express()
    app.use(express.json());
    app.listen(port, () => console.log(`Sample app listening on port ${port}!`))
    
    sequelize
    .authenticate()
    .then(() => {
       console.log('Connection has been established successfully.');
    })
    .catch(err => {
       console.error('Unable to connect to the database:', err);
    });
    
    const Inventory = sequelize.define('inventory', {
       id: { type: Sequelize.INTEGER, allowNull: false, primaryKey: true },
       name: { type: Sequelize.STRING, allowNull: false },
       quantity: { type: Sequelize.INTEGER },
       date: { type: Sequelize.DATEONLY, defaultValue: Sequelize.NOW }
    }, {
       freezeTableName: true,
       timestamps: false
    });
    
    app.post('/inventory', async (req, res) => {
       try {
          const newItem = new Inventory(req.body)
          await newItem.save()
          res.json({ inventory: newItem })
    } catch(error) {
          console.error(error)
    }})
    
    app.get('/inventory/:id', async (req, res) => {
    const id = req.params.id
       try {
          const inventory = await Inventory.findAll({
          attributes: ['id', 'name', 'quantity', 'date'],
          where: {
             id: id
          }})
          res.json({ inventory })
       } catch(error) {
          console.error(error)
    }})
    ```

## Validate the functionality of the Node.js Express web service

You're finally ready to test the functionality of your web service. You could containerize it at this point, but for the sake of simplicity, you'll deploy it to an Azure App Service. This will provide a quick way to validate its functionality and ensure that containerizing it is a viable option.

1. Within the web browser window displaying the Azure portal, from the Bash session on the **Cloud Shell** pane, run the following commands to create a resource group that will host the Azure web app, into which you'll deploy the Node.js Express app:

    ```azurecli-interactive
    RG1NAME=postgresql-db-RG
    LOCATION=$(az group show --resource-group $RG1NAME --query location --output tsv)
    RG2NAME=cna-express-RG
    az group create --name $RG2NAME --location $LOCATION
    ```

1. Run the following commands to create a Free-tier Azure App Service plan that will host the new Azure web app:

    ```azurecli-interactive
    SPNAME=express-sp
    az appservice plan create --name $SPNAME --resource-group $RG2NAME --sku F1
    ```

1. Run the following commands to create the new Node.js-based Azure web app:

    ```azurecli-interactive
    WEBAPPNAME=express$RANDOM$RANDOM
    az webapp create --name $WEBAPPNAME --resource-group $RG2NAME --plan $SPNAME --runtime "NODE|12-lts"
    ```

1. Run the following commands to initialize the local Git repository and commit all changes in the main branch:

    ```azurecli-interactive
    cd ~/cna-express
    git config --global user.email "user1@adatum.com"
    git config --global user.name "Adatum User1"
    git init
    git add -A
    git commit -m "Initial Commit"
    ```

1. Run the following commands to set up user-level deployment credentials:

    ```azurecli-interactive
    DEPLOYMENTUSER=m03User$RANDOM
    DEPLOYMENTPASS=m03Pass$RANDOM$RANDOM
    az webapp deployment user set --user-name $DEPLOYMENTUSER --password $DEPLOYMENTPASS
    ```

1. Run the following commands to identify the user-level deployment credentials. Record their values because you'll need them later in this task:

    ```azurecli-interactive
    echo $DEPLOYMENTUSER
    echo $DEPLOYMENTPASS
    ```

1. Run the following commands to identify the Azure web app deployment URL that you'll use as the target of the `git push` command:

    ```azurecli-interactive
    RG2NAME=cna-express-RG
    WEBAPPNAME=$(az webapp list --resource-group $RG2NAME --query "[0].name" --output tsv)
    DEPLOYMENTURL=$(az webapp deployment source config-local-git --name $WEBAPPNAME --resource-group $RG2NAME --output tsv)
    ```

1. Run the following command to configure the remote repo named **azure**, representing the deployment URL you identified in the previous step:

    ```azurecli-interactive
    git remote add azure $DEPLOYMENTURL
    ```

1. Run the following commands to create the **master** branch based on the **main** branch and push its content to the Azure web app (when prompted for the password that's part of the user-level deployment credentials you recorded previously in this task):

    ```azurecli-interactive
    git checkout -b master
    git commit -a -m "test"
    git push --set-upstream azure master
    ```

1. Run the following commands to validate the POST HTTP routing of the Node.js Express app:

    ```azurecli-interactive
    RG2NAME=cna-express-RG
    WEBAPPNAME=$(az webapp list --resource-group $RG2NAME --query "[0].name" --output tsv)
    curl --header "Content-Type: application/json" \
    --request POST \
    --data '{"id":3,"name":"ice cream","quantity":50}' \
    http://$WEBAPPNAME.azurewebsites.net/inventory
    ```
    
    > [!NOTE]
    > The command should return the values of the entries of the newly added table row, including the autogenerated date.

1. To validate the GET HTTP routing of the Node.js Express app, in the web browser that displays the **Cloud Shell** pane, open another tab, navigate to the [Azure portal](https://portal.azure.com?azure-portal=true), and then use the **Search resources, services, and docs** text box to search for the App Service web app you deployed. Navigate to its **Overview** blade, identify the value of **URL** property, append the string `/inventory/3` to that URL value, open another tab in the same browser window, and navigate to the newly constructed URL string to display the corresponding webpage.

    > [!NOTE]
    > The page should display the properties of the item you added to the **inventory** table of the **cnainventory** database in the previous step.

## Results

Congratulations! You've completed the second exercise of this module. In this exercise, you created and configured an Express.js-based web service that provides access to Azure Database for PostgreSQL.
