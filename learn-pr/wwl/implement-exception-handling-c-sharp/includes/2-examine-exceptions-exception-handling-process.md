

Runtime errors in a C# application are managed using a mechanism called exceptions. Exceptions provide a structured, uniform, and type-safe way of handling both system level and application-level error conditions. Exceptions can be generated by the .NET runtime or by the code in an application.

## Common scenarios that require exception handling

There are several common C# programming scenarios that require exception handling. Many of these scenarios involve some form of data acquisition. Although some of the scenarios involve coding techniques that are outside the scope of this training, they're still worth noting.

Common scenarios that may require exception handling include:

- User input: When processing user input, exceptions may occur if the input value is in the wrong format or out of range.

- Data processing and computations: When completing data calculations or conversions, exceptions may occur if the operation attempts to divide by zero, cast to an unsupported type, or assign a value that's out of range.

- File input/output operations: When reading from or writing to a file, exceptions may occur if the file does not exist, the program does not have permission to access the file, or the file is in use by another process.

- Database operations: When interacting with a database, exceptions may occur if the database connection is lost, a syntax error occurs in a SQL statement, or a constraint violation occurs.

- Network communication: When communicating over a network, exceptions may occur if the network connection is lost, a timeout occurs, or the remote server returns an error.

- Other external resources, such as Web Services, REST APIs, or third-party libraries, may throw exceptions for various reasons, like network connection errors, malformed data, etc.

## Exception handling keywords, code blocks, and patterns

Exception handling in C# is implemented by using the `try`, `catch`, and `finally` keywords. Each of these keywords has an associated code block and can be used to satisfy a specific goal in your approach to exception handling. For example:

```csharp
try
{
    // try code block
}
catch
{
    // catch code block
}
finally
{
    // finally code block
}
```

> [!NOTE]
> The C# language also enables your code to generate an exception object by using the `throw` keyword. Exception handling scenarios that include using the `throw` keyword to generate exceptions is covered in a separate module on Microsoft Learn.

The `try` code block contains the guarded code that may cause an exception. If the code within a `try` block causes an exception, the exception will be handled by the corresponding `catch`.

The `catch` code block contains the code that's executed when an exception is caught. The `catch` block can handle the exception, log it, or ignore it. A `catch` block can be configured so that it's executed when any exception type occurs, or only when a specific type of exception occurs.

The `finally` code block contains code that will execute whether an exception occurs or not. The `finally` block is often used to clean up any resources that're allocated in a `try` block. For example, ensuring that a variable has the correct or required value assigned to it.

Exception handling in a C# application is generally implemented using one or more of the following patterns:

- The `try-catch` pattern consists of a `try` block followed by one or more `catch` clauses. Each `catch` block is used to specify handlers for different exceptions.
- The `try-finally` pattern consists of a `try` block followed by a `finally` block. Typically, the statements of a `finally` block run when control leaves a `try` statement.
- The `try-catch-finally` pattern consists implements all three types of exception handling blocks. A common scenario for the `try-catch-finally` pattern is when resources are obtained and used in a `try` block, exceptional circumstances are managed in a `catch` block, and the resources are released or otherwise managed in the `finally` block.

## How are exceptions represented in code?

The `Exception` class is part of the .NET class library, which means exceptions can be accessed like other .NET classes. More precisely, exceptions are types, represented by classes, that are all ultimately derived from `System.Exception`. An exception class that's derived from `Exception` includes information that identifies the type of exception and contains properties that provide details about the exception. A more detailed examination of the `Exception` class is included later in this module.

A runtime instance of a class is generally referred to as an object, so exceptions are often referred to as exception objects.

> [!NOTE]
> Although they are sometimes used interchangeably, a class and an object are different things. A class defines a type of object, but it's not an object itself. An object is a concrete entity based on a class.

## Exception handling process

When an exception occurs, the .NET runtime searches for the nearest `catch` clause that can handle the exception. The process begins with the method that caused the exception to be thrown. First, the method is examined to see whether the code that caused the exception is inside a `try` code block. If the code is inside `try` code block, the `catch` clauses associated with the `try` statement are considered in order. If the `catch` clauses are unable to handle the exception, the method that called the current method is searched. This method is examined to determine whether the method call (to the first method) is inside a `try` code block. If the call is inside a `try` code block, the associated `catch` clauses are considered. This search process continues until a `catch` clause is found that can handle the current exception.

Once a `catch` clause is found that can handle the exception, the runtime prepares to transfer control to the first statement of the `catch` clause. However, before execution of the `catch` clause begins, the runtime executes any `finally` clauses associated with `try` statements found during the search. If more than one `finally` clause is found, they will be executed in order, starting with the one closest to the code that caused the exception to be thrown.

If no `catch` clause is found to handle the exception, the runtime will terminate the application and display an error message to the user.

This exception handling process is illustrated by the following code sample, which includes a `try-finally` pattern nested inside a `try-catch` pattern:

```csharp
try
{
    // Step 1: code execution begins

    try
    {
        // Step 2: an exception occurs here
    }
    finally
    {
        // Step 4: the system executes the finally code block associated with the try statement where the exception occurred
    }

}
catch // Step 3: the system finds a catch clause that can handle the exception
{
    // Step 5: the system transfers control to the first line of the catch code block
}
```

In this example, the following process occurs:

1. Execution begins in the code block of the outer `try` statement.
1. An exception is thrown in the code block of the inner `try` statement.
1. The runtime finds the `catch` clause associated with the outer `try` statement.
1. Before the runtime transfers control to the first line of the `catch` code block, it executes the `finally` clause associated with the inner `try` statement.
1. The runtime then transfers control to the first line of the `catch` code block and executes the code that handles the exception.

In this simple example, the nested `try-catch` and `try-finally` patterns reside within a single method, but multiple `try-catch` and `try-finally` patterns could be spread between methods that call other methods.

## Exception handling and the call stack

You'll often see the term "call stack unwinding" when you read about exception handling and the exception handling process. To understand this term, you need to understand the call stack and how it's used to track the "stack" of method calls during code execution.

You can think of the call stack like a tower of blocks. When you build a tower, you start with just one block. Each time you add a block to the tower, you place it on top of the existing blocks. When your application starts running in the debugger, the entry point to your application is the first layer added to the call stack. For a console application, the entry point to your application is the top-level statements. In the Visual Studio Code call stack, this entry point is referred to as the `Main` method. Each time a method calls another method, the new method is added to the top of the stack. When your code exits out of a method, the method is removed from the call stack.

Call stack unwinding is the process that the .NET runtime uses when a C# program encounters an error. It's the same process that you reviewed above.

Returning to the block tower analogy, when you need to remove a block from the tower, you start from the top and remove each block until you reach the one you need. This is similar to how call stack unwinding works, where each call layer in the stack is like a block in the tower. When the runtime needs to unwind the call stack, it starts from the top and removes each call layer until it reaches the one that has what it needs. In this case, the call layer that it needs is the method that has a `catch` clause that can handle the exception that occurred.
