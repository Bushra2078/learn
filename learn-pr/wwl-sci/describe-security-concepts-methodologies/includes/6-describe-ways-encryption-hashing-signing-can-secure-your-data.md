One way to mitigate against common cybersecurity threats is to encrypt sensitive or valuable data. Encryption is the process of making data unreadable and unusable to authorized viewers. To use or read encrypted data, it must be decrypted, which requires the use of a secret key. 

There are two top-level types of encryption: symmetric and asymmetric. Symmetric encryption uses the same key to encrypt and decrypt the data. Asymmetric encryption uses a public key and private key pair. Either key can encrypt data, but a single key can’t be used to decrypt encrypted data. To decrypt, you need a paired key. Asymmetric encryption is used for things like Transport Layer Security (TLS) such as the HTTPS protocol, and data signing. Encryption may protect data at rest, or in transit.

## Encryption at rest

Data at rest is the data that is stored on a physical device, such as a server.  It may be stored in a database, a storage account, but regardless of where it is stored, encryption of data at rest ensures that the data is unreadable without the keys and secrets needed to decrypt it.

If an attacker were to obtain a hard drive with encrypted data and did not have access to the encryption keys, the attacker would be unable to read the data.

## Encryption in transit

Data in transit is the data moving from one location to another, such as across the internet or through a private network. Secure transfer can be handled by several different layers. It could be done by encrypting the data at the application layer prior to sending it over a network. HTTPS is an example of encryption in-transit.

Encrypting data in transit protects the data from outside observers and provides a mechanism to transmit data while limiting the risk of exposure.

## Hashing

Hashing uses an algorithm to convert the original text to a *unique* fixed-length hash value. Each time the same text is hashed using the same algorithm, the same hash value is produced. That hash, then, can be used as a unique identifier of its associated data.

Hashing is different to encryption in that it does not use keys, and the hashed value is not subsequently decrypted back to the original.

Hashing is used to store passwords. When a user enters their password, the same algorithm that created the stored hash, creates a hash of the entered password. This is compared to the stored hashed version of the password. If they match, the user has entered their password correctly. This is more secure than storing plain text passwords, but hashing algorithms are also known to hackers. Because hash functions are deterministic (the same input produces the same output), hackers can use brute-force dictionary attacks by hashing the passwords. For every matched hash, they know the actual password. To mitigate this risk, passwords are often “salted”.  This refers to adding a fixed length random value to the input of hash functions to create unique hashes for every input. As hackers cannot know the salt value, the hashed passwords are more secure.

## Signing

Signing, using a digital signature, verifies that a message has been sent by the sender, and that the contents have not been tampered with. Signing a message does not encrypt or alter the message.

Signing works by creating a digital signature string that can either be sent with the message or transmitted separately. The digital signature is generated by the private key owner and attached to the message. The receiver can then verify that it was created by the key owner, by using the public key. This is illustrated below:

:::image type="content" source="../media/6-private-key-generates-the-signature.png" alt-text="A private key generates the signature":::

There are two steps involved in creating a digital signature from a message. First a hash value is created from the message. Secondly, the hash value is signed, using the signer's private key, as illustrated below:

:::image type="content" source="../media/6-hashed-using-a-hash-algorithm.png" alt-text="The message is hashed using a hashing algorithm, then signed":::

At the receiving end, the message is hashed again, and verified against the digital signature which is decrypted using the public key.

:::image type="content" source="../media/6-hash-value-verified.png" alt-text="The hash value is verified against the signature using signer’s public key":::

If they match, you can be confident that the message is the same one that signer originally signed, and that it has not been tampered with.
