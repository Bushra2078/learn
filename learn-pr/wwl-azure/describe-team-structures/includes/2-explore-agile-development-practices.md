## Waterfall

Traditional software development practices involve:

 -  Determining a problem.
 -  Analyzing the requirements.
 -  Building and testing the required code.
 -  The delivery outcome to users.

Usually, all refer to as a waterfall approach.

The waterfall model follows a sequential order. A project development team only moves to the next development phase or testing if the previous step is completed successfully.

It's what an engineer would do when building a bridge or a building. So, it might seem appropriate for software projects as well.

However, the waterfall methodology has some drawbacks. One relates to the customer requirements.

For example, It doesn't matter if the customer requirements are defined accurately at the start of a project.

Usually, the project takes a long time, and the outcome may no longer match the customer's needs.

There's a real challenge with gathering customer requirements in the first place.

Taking a long time to deliver something would often be different from what the customer needs, even if you built exactly what the customer asked.

Customers often don't know what they want until they see it or can't explain what they need.

## Agile

By comparison, Agile methodology constantly emphasizes adaptive planning and early delivery with continual improvement.

Rather than restricting development to rigid specifications, it encourages rapid and flexible responses to changes as they occur.

In 2001, highly regarded developers published a manifesto for Agile software development.

They said that:

 -  Development needs to favor individuals and interactions over processes and tools.
 -  Working software over comprehensive documentation.
 -  Customer collaboration over contract negotiation.
 -  Respond to changes over following a plan.

Agile software development methods are based on releases and iterations:

 -  One release might consist of several iterations.
 -  Each iteration is like a small independent project.
 -  After being estimated and prioritization:
    
     -  Features, bug fixes, enhancements, and refactoring width are assigned to a release.
     -  And then assigned again to a specific iteration within the release, generally on a priority basis.
 -  At the end of each iteration, there should be tested working code.
 -  In each iteration, the team must focus on the outcomes of the previous iteration and learn from them.

Having teams focused on shorter-term outcomes is that teams are also less likely to waste time over-engineering features. Or allowing unnecessary scope creep to occur.

Agile software development helps teams keep focused on business outcomes.

## Comparison of the waterfall and agile methodologies<br>

:::row:::
  :::column:::
    **Waterfall**
  :::column-end:::
  :::column:::
    **Agile**
  :::column-end:::
:::row-end:::
:::row:::
  :::column:::
    Divided into distinct phases.
  :::column-end:::
  :::column:::
    Separates the project development lifecycle into sprints.
  :::column-end:::
:::row-end:::
:::row:::
  :::column:::
    It can be rigid.
  :::column-end:::
  :::column:::
    Known for flexibility.
  :::column-end:::
:::row-end:::
:::row:::
  :::column:::
    All project development phases, such as design, development, and test, are completed once.
  :::column-end:::
  :::column:::
    It follows an iterative development approach so that each phase may appear more than once.
  :::column-end:::
:::row-end:::
:::row:::
  :::column:::
    Define requirements at the start of the project with little change expected.
  :::column-end:::
  :::column:::
    Requirements are expected to change and evolve.
  :::column-end:::
:::row-end:::
:::row:::
  :::column:::
    Focus on completing the project.
  :::column-end:::
  :::column:::
    Focus on meeting customers' demands.
  :::column-end:::
:::row-end:::
