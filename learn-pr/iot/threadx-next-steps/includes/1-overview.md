## Introduction

Congratulations on completing the ThreadX modules! You've learned a lot and you're now empowered to effectively use your newly acquired skills. However, there's much more to learn, and the purpose of this module is to summarize what you have learned, and to suggest next steps in your learning process.

## Highlights

Here are some highlights about ThreadX.

- ThreadX is easy to use.
- The ThreadX API is both intuitive and highly functional.
- The ThreadX API names are made of real words.
- All ThreadX APIs have a leading “tx_” and follow a noun-verb naming convention.
- There's functional consistency throughout the API.

ThreadX is advanced technology. Following is a list of advanced features available in ThreadX.

| &nbsp; | &nbsp; |
| :-- | :-- |
| Complete and comprehensive multithreading facilities | Run-Time performance metrics |
| Threads, application timers, message queues, counting semaphores, mutexes, event flags, memory block and memory byte pools | Event trace--capture last “n” system/application events |
| Priority-based preemptive scheduling | Event chaining™--register an application-specific “notify” callback function for each ThreadX communication or synchronization object |
| Priority flexibility--up to 1024 priority levels | ThreadX modules with optional memory protection |
| Cooperative scheduling | Execution profile kit (EPK) |
| Preemption-threshold™--unique to ThreadX, helps reduce context switches and helps guarantee schedulability | Separate interrupt stack |
| Memory protection via ThreadX modules | Run-time stack analysis |
| Fully deterministic | Optimized timer interrupt processing |

You probably recognize many of these features, but not all of them. In the following units, you'll be introduced to several ways that you can expand your ThreadX knowledge. However, we'll first explore some of the other components in Azure RTOS.
