
> [!VIDEO https://www.microsoft.com/videoplayer/embed/RE2Mn0x]

The pattern we want to follow when adding ONNX models to our UWP app is **Load** > **Bind** > **Evaluate**:

- Load the machine learning model.
- Bind inputs and outputs to the model.
- Evaluate the model and view results.

Open the `MainPage.xaml.cs` file. Then we can instantiate the model, inputs, and outputs that Visual Studio autogenerated for us when the model was added.

Inside the **MNIST_Demo** namespace and `MainPage` class, just above the `Helper` class, add the following code: 

```csharp
namespace MNIST_Demo
{
    public sealed partial class MainPage : Page
    {
    	private mnistModel modelGen;
    	private mnistInput mnistInput = new mnistInput();
    	private mnistOutput mnistOutput;

        private Helper helper = new Helper();
    	...
    }
}
```

## Load the model asynchronously

We created a method named **LoadModelAsync**. We followed C# naming conventions and included **Async** in the name because  it's used asynchronously, with `await`. The model is loaded asynchronously. So the evaluation process won’t interfere with our user interface fluidity. 

We want to ensure this **LoadModelAsync** method is called before we use any of the other methods. Examples are before the page's loaded event, `OnNavigatedTo` override, or anywhere before `recognizeButton_Click` is called. 

We need to set up a `StorageFile`, just like we would to access any other resource from our UWP app. We'll use it with our model to make method calls from the classes generated when we added our ONNX model to the project. We want to point the `StorageFile` to our model in the **Assets** folder: `ms-appx:///Assets/mnist.onnx`. Add the following code inside our `LoadModelAsync` task: 

```csharp
private async Task LoadModelAsync()
{
    //Load a machine learning model
    StorageFile modelFile = await StorageFile.GetFileFromApplicationUriAsync(new Uri("ms-appx:///Assets/mnist.onnx"));
    modelGen = await mnistModel.CreateFromStreamAsync(modelFile as IRandomAccessStreamReference);
}
```

The `mnistModel` class represents the MNIST machine learning ONNX model. It creates the session on the system default device. To load the model, we call the `CreateFromStreamAsync` method, passing in the ONNX file as the parameter. The method autogenerated within the `mnistModel` class when we added the ONNX model to Visual Studio.

This functioning is all asynchronous. So we can add an `await`. And the Windows ML process isn't going to get in the way of anything. While our model performs an evaluation, our UI is still fluid. 

## Bind inputs to the model

Now we’ve loaded the model file. The next step is to provide the model with the type of input it expects. 

Add the following code inside the `recognizeButton_Click` event:

```csharp
private async void recognizeButton_Click(object sender, RoutedEventArgs e)
{
    //Bind model input with contents from InkCanvas
    VideoFrame vf = await helper.GetHandWrittenImage(inkGrid);
    mnistInput.Input3 = ImageFeatureValue.CreateFromVideoFrame(vf);
}
```

One of the classes we instantiated is called `mnistInput`. It's based on the input class generated from within the ONNX model when we added it to Visual Studio. By looking in the `mnistInput` class, we see the `Input3` property and that it expects an `ImageFeatureValue`. 

Image files often require a lot of work to massage the file format into the input type that the model expects. Windows ML abstracts that away by using `VideoFrame` as the currency of data exchange between the UI layer and what the model expects. By using this Windows ML standard `ImageFeatureValue` class, we can call `CreateFromVideoFrame`. We take these steps with the `helper.cs` function we instantiated earlier:
* Grab the contents that we draw into the InkCanvas.
* Convert it to a `VideoFrame`.
* Bind it to our model inside the `recognizeButton_Click` event. 

Now we’ve hooked up the InkCanvas. So it creates a `videoFrame` that provides the type of input our ONNX model expects. The next step is to evaluate the model and get an output.

## Bind output to the model

By looking in our VS-generated `modelGen` class, we see that an `EvaluateAsync` method has been provided. By using the `mnistOutput` class instantiated earlier, we can pass our `mnistInput` into this `EvaluateAsync` method. It performs the evaluation on our InkCanvas drawing.

Add the following code inside the `recognizeButton_Click` event, below the code to bind the model input:

```csharp
//Evaluate the model
    mnistOutput = await modelGen.EvaluateAsync(modelInput);
```

Now when we select the **Recognize** button, the model converts our InkCanvas content to a `videoFrame`. The model feeds it to our ML model `Input3` property as the `ImageFeatureValue` data type. Then the model evaluates that input data with the `EvaluateAsync` method and passes the results back to the `mnistOutput`. 

At this point, we’ve written all the code you need to load a model, bind inputs and outputs to that model, and call an evaluation. Now we'll handle the evaluation results from that model output. 

## Display evaluation results

The model returns a `TensorFloat` as the output `Plus214_Output_0`, as found in the generated `mnistOutput` class. First we convert it to a friendly data type with the `GetAsVectorView` method. Then we can work with the array in C#. For this particular ML model, the output is a prediction of the digit that we just drew on the screen. It's based on a list of 10 numbers, 0 to 9. 

Add the following code inside the `recognizeButton_Click` event, below the code to evaluate the model:

```csharp
    //Convert output to datatype
    IReadOnlyList<float> vectorImage = mnistOutput.Plus214_Output_0.GetAsVectorView();
    IList<float> imageList = vectorImage.ToList();
```

The array converts to a vector list. Then we can parse the returned list to determine which digit had the highest probability and display that one. 

Add the following code inside the `recognizeButton_Click` event, below where we converted the output data type:

```csharp
    //Query to check for highest probability digit
    var maxIndex = imageList.IndexOf(imageList.Max());
```
 
Now we can display that digit result as text in our `numberLabel` display field.

Add the following code to display the number with the highest probability of being accurate to what the drawing intends:

```csharp
    //Display the results
    numberLabel.Text = maxIndex.ToString();
```

## Clear the InkCanvas

Finally, we want to include code in our **Clear Digit** button. The code clears out the InkCanvas, so users can draw and evaluate another number.

Add `numberLabel.Text="";` inside the `clearButton_Click` event:

```csharp
private void clearButton_Click(object sender, RoutedEventArgs e)
{
    inkCanvas.InkPresenter.StrokeContainer.Clear();
    numberLabel.Text = "";
}
```

## Open the application

To build and open the application, select the **▶ Local Machine** button on your Visual Studio top menu bar. After the application opens, we draw a number on the **InkCanvas** by using the mouse, touchscreen, or pen. Then select the **Recognize** button to ask our MNIST machine learning model to evaluate and identify the number drawn based on our 0 to 9 scale of digits. 

![Screen shot depicting the finished application running with results displayed in the U I.](../media/MNIST_app_screenshot2.png)

### Finished code file

The finished code for our `MainPage.xaml.cs` file should read as follows:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Windows.Foundation;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.Storage;
using Windows.UI.Xaml.Media.Imaging;
using Windows.AI.MachineLearning;
using Windows.Media;
using Windows.Storage.Streams;
using System.Threading.Tasks;

namespace MNIST_Demo
{
    public sealed partial class MainPage : Page
    {
        private mnistModel modelGen;
        private mnistInput mnistInput = new mnistInput();
        private mnistOutput mnistOutput;
        
        private Helper helper = new Helper();
        RenderTargetBitmap renderBitmap = new RenderTargetBitmap();

        public MainPage()
        {
            this.InitializeComponent();

            // Set supported inking device types.
            inkCanvas.InkPresenter.InputDeviceTypes = Windows.UI.Core.CoreInputDeviceTypes.Mouse | Windows.UI.Core.CoreInputDeviceTypes.Pen | Windows.UI.Core.CoreInputDeviceTypes.Touch;
            inkCanvas.InkPresenter.UpdateDefaultDrawingAttributes(
                new Windows.UI.Input.Inking.InkDrawingAttributes()
                {
                    Color = Windows.UI.Colors.White,
                    Size = new Size(22, 22),
                    IgnorePressure = true,
                    IgnoreTilt = true,
                }
            );
            Task.Run(async () => await LoadModelAsync());
        }

        private async Task LoadModelAsync()
        {
            //Load a machine learning model
            StorageFile modelFile = await StorageFile.GetFileFromApplicationUriAsync(new Uri("ms-appx:///Assets/mnist.onnx"));
            modelGen = await mnistModel.CreateFromStreamAsync(modelFile as IRandomAccessStreamReference);
        }

        private async void recognizeButton_Click(object sender, RoutedEventArgs e)
        {
            //Bind model input with contents from InkCanvas
            VideoFrame vf = await helper.GetHandWrittenImage(inkGrid);
            mnistInput.Input3 = ImageFeatureValue.CreateFromVideoFrame(vf);
            
            //Evaluate the model
            mnistOutput = await modelGen.EvaluateAsync(mnistInput);

            //Convert output to datatype
            IReadOnlyList<float> vectorImage = mnistOutput.Plus214_Output_0.GetAsVectorView();
            IList<float> imageList = vectorImage.ToList();

            //LINQ query to check for highest probability digit
            var maxIndex = imageList.IndexOf(imageList.Max());

            //Display the results
            numberLabel.Text = maxIndex.ToString();
        }

        private void clearButton_Click(object sender, RoutedEventArgs e)
        {
            inkCanvas.InkPresenter.StrokeContainer.Clear();
            numberLabel.Text = "";
        }
    }
}
```
