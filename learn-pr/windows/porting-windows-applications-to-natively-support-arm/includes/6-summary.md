In this module, you learned that Arm-based devices are becoming increasingly popular due to their long battery life, best-in-class connectivity, and impressive processing power. Therefore, porting existing Windows applications to run natively on this rapidly growing platform makes sense. You learned that providing an Arm-native build of a Windows application offers your end users the best performance and experience. You performed an exercise demonstrating step-by-step how to add an Arm64 build to a Windows application. Finally, you learned some obstacles you might encounter when porting your applications to Arm and some valuable strategies to apply to achieve the goal of a 100% Arm-native application version.

## References

*[Windows on Arm overview](/windows/arm/overview)
*[Arm64EC (Emulation Compatible) builds](/windows/arm/arm64ec)
*[Arm64X binary encapsulation](/windows/arm/arm64x-pe)
*[Visual Studio for Arm](/visualstudio/install/visual-studio-on-arm-devices)
*[Microsoft Windows 11 Preview arm64 virtual machine marketplace link]( https://azuremarketplace.microsoft.com/marketplace/apps/microsoftwindowsdesktop.windows11preview-arm64?tab=Overview)
*[Ampere Altra announcement]( https://azure.microsoft.com/blog/azure-virtual-machines-with-ampere-altra-arm-based-processors-generally-available/)
Remote debugging (visual studio)
*[NuGet package manager service](https://www.nuget.org)
*[vcpkg package manager service](https://vcpkg.io/)
*[Linaro - a company that specializes in porting code to Arm](https://www.linaro.org/)
*[Microsoft App Assure program](https://www.microsoft.com/fasttrack/microsoft-365/app-assure)
