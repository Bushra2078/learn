Recall that you are a developer for a company that owns a popular Windows accounting application. The company has decided to update the application to include support for Windows on Arm. In preparation for this, you began reviewing the code base. You quickly realize a 3rd party dependency that provides charting components inside the application does not offer an Arm-based version - only x64. Let's review some potential strategies to help reach your goal of delivering an Arm build for the application. 

As a first step, you should contact the 3rd party charting dependency owner and ask for it to be updated to support Arm. The dependency owner may already have an initiative underway or can add this effort to their ongoing roadmap. Updated assemblies can be provided directly or via package management services, including NuGet and vcpkg. In this case, the 3rd party dependency owner is unresponsive to our request.

Another strategy is to reach out to a company specializing in updating code to support Arm, such as Linaro. However, Linaro determines that porting the charting component dependency is too extensive to update in this case.

The remaining options to attain the goal of a fully Arm-native build are replacing or rewriting the charting component dependency. The company decides to take the approach of rewriting the charting dependency component in-house. You feel comfortable with this decision as you have recently learned of the App Assure program through Microsoft that offers free assistance to remediate any blocking issues that may arise with the new charting dependency code that would prevent it from running natively on the Arm versions of Windows. However, rewriting the charting dependency will take some time, and you don't want this setback to prevent the accounting application from being provided in at least a partial Arm-native implementation.

An Arm64EC (Arm64 Emulation Capable) build allows you to rebuild parts of the application as Arm-native while continuing support for the emulation of the 3rd party charting component dependency. Because the charting component has a large codebase, an Arm64EC build also provides a path to transition the code to being Arm-native incrementally over time. As a result, the performance will gradually increase as portions of the charting component are rewritten with Arm-native code. Keep in mind creating an Arm64EC build is a more advanced and intensive route to porting a complex application.
