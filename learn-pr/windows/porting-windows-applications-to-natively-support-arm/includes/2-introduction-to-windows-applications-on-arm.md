The Windows operating system is best known for supporting Intel-based x86 and x64-based processors. However, since Windows 10, processor support has expanded to include Arm-based processors. Arm-based devices are becoming increasingly popular due to their power-frugal nature, longer battery life, and impressive processing power via CPU and GPU processors. Arm-based devices are also known for best-in-class data connectivity with Wi-Fi and mobile capabilities. In addition, Windows on Arm includes support for Neural Processing Units (NPU) tuned for the increasingly popular AI and machine learning workloads.

Traditionally Windows applications target popular Intel-based processors, such as x86 and x64. On Arm devices, through emulation, Windows 10 on Arm supports x86 application builds without modification, and Windows 11 on Arm expands this support to include unmodified x64 applications. This emulation means that developers can be confident that their existing x86 and x64 applications run on Arm-based devices without modifying the underlying source code. However, while running application code for x86/x64 on the Arm platform is possible, developers must build Arm-native applications to yield the best performance, as emulation inherently introduces processing overhead.

> **Note**: Arm32 app configurations are no longer supported and should be updated to Arm64.

Ideally, adding an ARM build configuration to your application will provide a seamless Arm-native build. However, this is not always the case; if your application contains dependencies on x86/x64 code that cannot be compiled in the ARM configuration, you may need to consider a solution like the Arm64EC (Emulation Compatible) build configuration. Arm64EC offers a hybrid option that allows Arm-native code to run alongside x86/x64 code. If you need to rebuild your code using Arm64EC, you can focus on optimizing critical code that would benefit most from being Arm-native, while leaving other parts of the project to use emulation.

The following image demonstrates multiple build versions of an application. Remember that while emulation does allow x86 and x64 versions to run, it is not the most efficient, and our goal should be 100% Arm-native code. If an application build has only an x86 build, it will run via full emulation on Windows 10 on Arm and Windows 11 on Arm operating systems. An Arm64EC build provides a middle-ground solution where part of the application runs with emulation, and part runs natively. It is important to note that Arm64EC is a Windows 11 on Arm feature. Lastly, a full Arm-native version will run without the assistance of emulation and will provide the best performance and experience to the user.

:::image type="content" source="../media/windows-arm-application-support.png" alt-text="A Windows Arm application support diagram displays Windows 10 on Arm support for x86 builds and Windows 11 on Arm support for both x86 and x64 builds through emulation. An Arm-native build is shown with no emulation necessary with Windows 11 on Arm and a Arm64EC build that uses both native and emulation code.":::

In porting a Windows application to Arm, it is possible to end up with multiple build versions such as x64, Arm64, and Arm64EC binaries. In this case, you can choose to encapsulate all of these builds into a single Arm64X binary. Arm64X introspects all implementations and eliminates redundant code as well as provides runtime support to expose the most optimal build based on the device processor architecture.

Similarly, when installing applications from the Microsoft Store, Windows will automatically select the most optimal version of the application based on the builds provided and the device's current processor architecture. Therefore, if you provide builds for both x64 and Arm64 for your application, Windows 11 for Arm will automatically install the Arm64 build, whereas an Intel-based Windows 11 device will install the x64 build.
