Recall that you are a developer for a company that owns a popular Windows accounting application. The company has decided to update the application to include support for Windows on Arm. In preparation for this, you began reviewing the code base. You quickly realize a 3rd party dependency that provides charting components inside the application does not offer an Arm-based version - only x64. Let's review some potential strategies to help reach your goal of delivering an Arm build for the application. 

As a first step, you should contact the 3rd party charting dependency owner and ask for it to be updated to support Arm. The dependency owner may already have an initiative underway or can add this effort to their ongoing roadmap. Updated assemblies can be provided directly or via package management services, including NuGet and vcpkg. In this case, the 3rd party dependency owner is unresponsive to our request.

Another strategy is to reach out to a company specializing in updating code to support Arm, such as Linaro. However, Linaro determines that porting the charting component dependency is too extensive to update in this case.

The remaining options to attain the goal of a fully Arm-native build are replacing or rewriting the charting component dependency. The company decides to take the approach of rewriting the charting dependency component in-house. You feel comfortable with this decision as you have recently learned of the App Assure program through Microsoft that offers free assistance to remediate any blocking issues that may arise with the new charting dependency code that would prevent it from running natively on the Arm versions of Windows. However, rewriting the charting dependency will take some time, and you don't want this setback to prevent the accounting application from being provided in at least a partial Arm-native implementation.

An Arm64EC (Arm64 Emulation Capable) build allows you to rebuild parts of the application as Arm-native while continuing support for the emulation of the 3rd party charting component dependency. Because the charting component has a large codebase, an Arm64EC build also provides a path to transition the code to being Arm-native incrementally over time. As a result, the performance will gradually increase as portions of the charting component are rewritten with Arm-native code.

For example, the following image demonstrates the performance of four incremental builds moving a generic Windows application from being 100% emulated to being 100% Arm-native. Observe the performance increase as the application moves from a fully emulated workload to 100% Arm-native code.

:::image type="content" source="../media/arm64ec-performance-incremental-implementation.png "Arm64EC incremental builds"" alt-text="An incremental build of an application demonstrating the performance of four incremental builds. The first build shows the largest compute time with code running 100% as x64 emulation. Each iteration increases performance by moving additional application code to Arm64EC native. The best performance is obtained with 100% emulated code.":::

Depending on the plug-ins and dependencies used within an application, it is possible to end up with multiple build versions such as x64, Arm64, and Arm64EC binaries. If so, it makes sense to combine these builds within a new type of binary to contain them all: Arm64X. Arm64X encapsulates all build versions' code and entry points while eliminating redundant parts to save disk space. At runtime, depending on the device and application architecture, the operating system will automatically apply transformations at runtime to expose the correct underlying implementation.
